# Recurring Invoice Implementation Guide

## Overview
This document outlines the complete implementation of Stripe Subscriptions support for recurring invoices in the barely.ai invoice system. This adds subscription capabilities while maintaining the existing Payment Intent system for one-time payments.

## Current State
- ✅ Payment Intents working for one-time invoice payments
- ✅ Embedded Stripe Elements UI implemented
- ✅ Basic invoice creation and payment flow complete

## New Features to Implement
1. **Invoice Types**: oneTime, recurring, recurringOptional
2. **Recurring Discounts**: Incentivize subscription payments
3. **Payment Toggle**: Let customers choose recurring vs one-time
4. **Subscription Management**: Handle recurring billing lifecycle

---

## Phase 1: Database Schema Updates

### Files to Modify:
- `packages/db/src/sql/invoice.sql.ts`
- `packages/validators/src/schemas/invoice.schema.ts`

### Invoice Table Additions:
```sql
-- Add these columns to Invoice table
subscriptionId: text('subscriptionId'), -- Links to Stripe subscription
billingInterval: text('billingInterval').$type<'monthly' | 'quarterly' | 'yearly'>(), 
type: text('type').$type<'oneTime' | 'recurring' | 'recurringOptional'>().default('oneTime').notNull(),
recurringDiscountPercent: real('recurringDiscountPercent').default(0).notNull(),
```

### Validator Schema Updates:
```typescript
// In invoice.schema.ts
export const invoiceSchema = z.object({
  // ... existing fields
  subscriptionId: z.string().nullable(),
  billingInterval: z.enum(['monthly', 'quarterly', 'yearly']).nullable(),
  type: z.enum(['oneTime', 'recurring', 'recurringOptional']).default('oneTime'),
  recurringDiscountPercent: z.number().min(0).max(100).default(0),
});

export const createInvoiceSchema = invoiceSchema.omit({
  // ... existing omissions
  subscriptionId: true, // Generated by Stripe
});

export const updateInvoiceSchema = createInvoiceSchema.partial();
```

### Migration Steps:
1. Add new columns to Invoice table
2. Run `pnpm db:push` to apply schema changes
3. Update TypeScript types and validators
4. Test with existing invoices (should default to oneTime)

---

## Phase 2: Backend Function Updates

### Files to Modify/Create:
- `packages/lib/src/functions/invoice-payment.fns.ts` (modify existing)
- `packages/lib/src/functions/invoice-subscription.fns.ts` (new)
- `packages/lib/src/functions/stripe-connect.fns.ts` (modify existing)

### New Function: `createInvoiceSubscription()`
```typescript
// packages/lib/src/functions/invoice-subscription.fns.ts
export async function createInvoiceSubscription({
  invoice,
  workspace,
  customerId,
}: {
  invoice: Invoice;
  workspace: Pick<Workspace, 'currency' | 'stripeConnectAccountId' | 'stripeConnectAccountId_devMode' | 'stripeConnectChargesEnabled' | 'stripeConnectChargesEnabled_devMode'>;
  customerId: string;
}) {
  // Validation checks (similar to payment intent)
  const stripeChargesEnabled = isProduction() ? 
    workspace.stripeConnectChargesEnabled : 
    workspace.stripeConnectChargesEnabled_devMode;
    
  if (!stripeChargesEnabled) {
    throw new Error('Payment processing is not enabled for this workspace');
  }

  const stripeConnectAccountId = getStripeConnectAccountId(workspace);
  if (!stripeConnectAccountId) {
    throw new Error('Stripe account not configured for this workspace');
  }

  // Calculate recurring total with discount
  const recurringTotal = calculateRecurringTotal(invoice.total, invoice.recurringDiscountPercent);
  const platformFeeAmount = Math.round(recurringTotal * libEnv.PLATFORM_INVOICE_FEE_PERCENTAGE);

  const metadata = {
    paymentType: 'invoice' as const,
    invoiceId: invoice.id,
    workspaceId: invoice.workspaceId,
    invoiceNumber: invoice.invoiceNumber,
  };

  // Create subscription
  const subscription = await stripe.subscriptions.create({
    customer: customerId,
    items: [{
      price_data: {
        currency: workspace.currency,
        product_data: {
          name: `Invoice ${invoice.invoiceNumber}`,
          description: `Recurring payment for invoice ${invoice.invoiceNumber}`,
        },
        unit_amount: recurringTotal,
        recurring: { interval: invoice.billingInterval || 'monthly' },
      }
    }],
    application_fee_percent: (libEnv.PLATFORM_INVOICE_FEE_PERCENTAGE * 100), // Convert to percentage
    metadata,
    expand: ['latest_invoice.payment_intent'],
  }, { stripeAccount: stripeConnectAccountId });

  return {
    subscriptionId: subscription.id,
    clientSecret: subscription.latest_invoice?.payment_intent?.client_secret,
    stripeConnectAccountId,
  };
}
```

### New Function: `calculateRecurringTotal()`
```typescript
export function calculateRecurringTotal(originalTotal: number, discountPercent: number): number {
  if (discountPercent <= 0) return originalTotal;
  
  const discountAmount = Math.round(originalTotal * (discountPercent / 100));
  return originalTotal - discountAmount;
}

export function calculateRecurringDiscount(originalTotal: number, discountPercent: number): number {
  return Math.round(originalTotal * (discountPercent / 100));
}

export function calculateAnnualSavings(originalTotal: number, discountPercent: number, billingInterval: string): number {
  const monthlyDiscount = calculateRecurringDiscount(originalTotal, discountPercent);
  
  switch (billingInterval) {
    case 'monthly': return monthlyDiscount * 12;
    case 'quarterly': return monthlyDiscount * 4;
    case 'yearly': return monthlyDiscount;
    default: return 0;
  }
}
```

### Update: `createInvoicePaymentIntent()`
```typescript
// Modify existing function to handle routing
export async function createInvoicePaymentIntent({ invoice, workspace }: { ... }) {
  // Add check for invoice type
  if (invoice.type === 'recurring') {
    throw new Error('Recurring invoices should use subscription creation, not payment intents');
  }
  
  // Existing payment intent logic remains the same
  // ...
}
```

### Update Webhook Handler: `handleStripeInvoiceChargeSuccess()`
```typescript
// In stripe-connect.fns.ts - modify existing function
export async function handleStripeInvoiceChargeSuccess(charge: Stripe.Charge, metadata: ...) {
  // Existing logic...
  
  // After marking invoice as paid, check if it's from a subscription
  if (charge.invoice) {
    // This is a subscription payment, update subscription ID if not already set
    const { eq } = await import('drizzle-orm');
    const { Invoices } = await import('@barely/db/sql/invoice.sql');
    
    await dbHttp.update(Invoices)
      .set({ 
        subscriptionId: charge.invoice.subscription?.toString(),
        updatedAt: new Date(),
      })
      .where(eq(Invoices.id, invoiceId));
  }
}
```

### New Webhook Handler: `handleStripeSubscriptionEvents()`
```typescript
export async function handleStripeSubscriptionUpdated(subscription: Stripe.Subscription) {
  console.log('🔄 Processing subscription update:', subscription.id);
  
  // Find invoice by subscription ID
  const { eq } = await import('drizzle-orm');
  const { Invoices } = await import('@barely/db/sql/invoice.sql');
  
  const invoice = await dbHttp.query.Invoices.findFirst({
    where: eq(Invoices.subscriptionId, subscription.id),
  });
  
  if (!invoice) {
    console.log('No invoice found for subscription:', subscription.id);
    return;
  }
  
  // Update invoice status based on subscription status
  let newStatus = invoice.status;
  if (subscription.status === 'active') {
    newStatus = 'paid';
  } else if (subscription.status === 'canceled') {
    newStatus = 'voided';
  }
  
  if (newStatus !== invoice.status) {
    await dbHttp.update(Invoices)
      .set({ status: newStatus, updatedAt: new Date() })
      .where(eq(Invoices.id, invoice.id));
  }
}

export async function handleStripeSubscriptionDeleted(subscription: Stripe.Subscription) {
  console.log('❌ Processing subscription cancellation:', subscription.id);
  // Similar logic to mark invoice as voided/canceled
}
```

---

## Phase 3: API Route Updates

### Files to Modify:
- `packages/api/src/public/invoice-render.route.ts`

### New Endpoint: `createRecurringPayment`
```typescript
createRecurringPayment: publicProcedure
  .input(z.object({
    handle: z.string(),
    invoiceId: z.string(),
    customerEmail: z.string(), // For customer creation
  }))
  .mutation(async ({ input, ctx }) => {
    // Rate limiting
    const ip = ctx.visitor?.ip ?? 'anonymous';
    const ipRateLimit = ratelimit(10, '1 m');
    const { success } = await ipRateLimit.limit(ip);
    
    if (!success) {
      throw new TRPCError({
        code: 'TOO_MANY_REQUESTS',
        message: 'Too many payment attempts, please try again later',
      });
    }
    
    // Get invoice with validation (similar to existing endpoints)
    const invoice = await dbHttp.query.Invoices.findFirst({
      where: and(eq(Invoices.id, input.invoiceId), isNull(Invoices.deletedAt)),
      with: { workspace: { columns: { /* ... */ } } }
    });
    
    if (!invoice || invoice.workspace.handle !== input.handle) {
      throw new Error('Invoice not found or invalid handle');
    }
    
    if (invoice.status === 'paid') {
      throw new Error('Invoice has already been paid');
    }
    
    if (invoice.type !== 'recurring' && invoice.type !== 'recurringOptional') {
      throw new Error('Invoice does not support recurring payments');
    }
    
    // Create or get Stripe customer
    const stripeConnectAccountId = getStripeConnectAccountId(invoice.workspace);
    const customer = await stripe.customers.create({
      email: input.customerEmail,
      metadata: {
        invoiceId: invoice.id,
        workspaceId: invoice.workspaceId,
      }
    }, { stripeAccount: stripeConnectAccountId });
    
    // Create subscription
    const subscription = await createInvoiceSubscription({
      invoice,
      workspace: invoice.workspace,
      customerId: customer.id,
    });
    
    return subscription;
  }),
```

### New Endpoint: `getRecurringPaymentOptions`
```typescript
getRecurringPaymentOptions: publicProcedure
  .input(z.object({
    handle: z.string(),
    invoiceId: z.string(),
  }))
  .query(async ({ input }) => {
    // Get invoice (similar validation as other endpoints)
    const invoice = await dbHttp.query.Invoices.findFirst({
      where: and(eq(Invoices.id, input.invoiceId), isNull(Invoices.deletedAt)),
      with: { workspace: { columns: { currency: true, handle: true } } }
    });
    
    if (!invoice || invoice.workspace.handle !== input.handle) {
      throw new Error('Invoice not found');
    }
    
    // Calculate pricing options
    const oneTimeTotal = invoice.total;
    const recurringTotal = calculateRecurringTotal(invoice.total, invoice.recurringDiscountPercent);
    const discountAmount = calculateRecurringDiscount(invoice.total, invoice.recurringDiscountPercent);
    const annualSavings = calculateAnnualSavings(invoice.total, invoice.recurringDiscountPercent, invoice.billingInterval || 'monthly');
    
    return {
      oneTime: {
        total: oneTimeTotal,
        label: 'Pay Once',
      },
      recurring: {
        total: recurringTotal,
        originalTotal: oneTimeTotal,
        discountAmount,
        discountPercent: invoice.recurringDiscountPercent,
        billingInterval: invoice.billingInterval || 'monthly',
        annualSavings,
        label: `Pay ${invoice.billingInterval || 'Monthly'}`,
      },
      currency: invoice.workspace.currency,
    };
  }),
```

### Update Existing Endpoint: `createPaymentIntent`
```typescript
// Modify existing createPaymentIntent to handle type routing
createPaymentIntent: publicProcedure
  .input(z.object({
    handle: z.string(),
    invoiceId: z.string(),
    paymentType: z.enum(['oneTime', 'recurring']).optional(), // For recurringOptional invoices
  }))
  .mutation(async ({ input, ctx }) => {
    // ... existing validation logic
    
    if (invoice.type === 'recurring') {
      throw new Error('Recurring invoices should use the subscription endpoint');
    }
    
    if (invoice.type === 'recurringOptional' && input.paymentType === 'recurring') {
      throw new Error('Use createRecurringPayment endpoint for recurring payments');
    }
    
    // Continue with existing PaymentIntent logic for oneTime payments
    // ...
  }),
```

---

## Phase 4: Frontend Payment Page Updates

### Files to Modify:
- `apps/invoice/src/app/pay/[handle]/[invoiceId]/invoice-payment-client.tsx`
- Create: `apps/invoice/src/app/pay/[handle]/[invoiceId]/_components/payment-type-toggle.tsx`

### New Component: `PaymentTypeToggle`
```typescript
// _components/payment-type-toggle.tsx
'use client';

import { useState } from 'react';
import { formatMinorToMajorCurrency } from '@barely/utils';

interface PaymentOptions {
  oneTime: { total: number; label: string };
  recurring: {
    total: number;
    originalTotal: number;
    discountAmount: number;
    discountPercent: number;
    billingInterval: string;
    annualSavings: number;
    label: string;
  };
  currency: string;
}

interface PaymentTypeToggleProps {
  options: PaymentOptions;
  selectedType: 'oneTime' | 'recurring';
  onTypeChange: (type: 'oneTime' | 'recurring') => void;
}

export function PaymentTypeToggle({ options, selectedType, onTypeChange }: PaymentTypeToggleProps) {
  return (
    <div className="space-y-4">
      <Text variant="lg/semibold" className="text-gray-900">
        Choose Payment Option
      </Text>
      
      {/* Recurring Option (Default) */}
      <div 
        className={cn(
          "cursor-pointer rounded-lg border-2 p-4 transition-all",
          selectedType === 'recurring' ? "border-blue-500 bg-blue-50" : "border-gray-200 hover:border-gray-300"
        )}
        onClick={() => onTypeChange('recurring')}
      >
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <input
              type="radio"
              checked={selectedType === 'recurring'}
              onChange={() => onTypeChange('recurring')}
              className="h-4 w-4 text-blue-600"
            />
            <div>
              <Text variant="md/semibold" className="text-gray-900">
                {options.recurring.label}
              </Text>
              <Text variant="sm/normal" className="text-gray-600">
                Automatically renews every {options.recurring.billingInterval}
              </Text>
            </div>
          </div>
          <div className="text-right">
            <Text variant="lg/semibold" className="text-gray-900">
              {formatMinorToMajorCurrency(options.recurring.total, options.currency)}
            </Text>
            {options.recurring.discountAmount > 0 && (
              <Text variant="sm/normal" className="text-gray-500 line-through">
                {formatMinorToMajorCurrency(options.recurring.originalTotal, options.currency)}
              </Text>
            )}
          </div>
        </div>
        
        {options.recurring.annualSavings > 0 && (
          <div className="mt-2 rounded bg-green-100 px-3 py-2">
            <Text variant="sm/medium" className="text-green-800">
              💰 Save {formatMinorToMajorCurrency(options.recurring.annualSavings, options.currency)} per year
            </Text>
          </div>
        )}
      </div>

      {/* One-time Option */}
      <div 
        className={cn(
          "cursor-pointer rounded-lg border-2 p-4 transition-all",
          selectedType === 'oneTime' ? "border-blue-500 bg-blue-50" : "border-gray-200 hover:border-gray-300"
        )}
        onClick={() => onTypeChange('oneTime')}
      >
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <input
              type="radio"
              checked={selectedType === 'oneTime'}
              onChange={() => onTypeChange('oneTime')}
              className="h-4 w-4 text-blue-600"
            />
            <div>
              <Text variant="md/semibold" className="text-gray-900">
                {options.oneTime.label}
              </Text>
              <Text variant="sm/normal" className="text-gray-600">
                Single payment, no recurring charges
              </Text>
            </div>
          </div>
          <Text variant="lg/semibold" className="text-gray-900">
            {formatMinorToMajorCurrency(options.oneTime.total, options.currency)}
          </Text>
        </div>
      </div>
    </div>
  );
}
```

### Update: `InvoicePaymentClient`
```typescript
export function InvoicePaymentClient({ handle, invoiceId }: InvoicePaymentClientProps) {
  const [showPaymentModal, setShowPaymentModal] = useState(false);
  const [paymentError, setPaymentError] = useState<string | null>(null);
  const [paymentIntent, setPaymentIntent] = useState<{
    clientSecret: string;
    stripeConnectAccountId: string;
  } | null>(null);
  
  // New state for recurring payment option
  const [selectedPaymentType, setSelectedPaymentType] = useState<'oneTime' | 'recurring'>('recurring');
  const [paymentOptions, setPaymentOptions] = useState<PaymentOptions | null>(null);
  
  const trpc = useInvoiceRenderTRPC();

  // Get invoice data (existing)
  const { data: invoice, isLoading, error } = useQuery({
    ...trpc.getInvoiceByHandle.queryOptions({ handle, invoiceId }),
    retry: false,
  });

  // Get payment options for recurringOptional invoices
  const { data: options } = useQuery({
    ...trpc.getRecurringPaymentOptions.queryOptions({ handle, invoiceId }),
    enabled: invoice?.type === 'recurringOptional',
  });

  // Set payment options when data loads
  useEffect(() => {
    if (options) {
      setPaymentOptions(options);
    }
  }, [options]);

  // Updated payment intent creation
  const createPaymentIntent = useMutation({
    ...trpc.createPaymentIntent.mutationOptions(),
    onSuccess: data => {
      if (!data.clientSecret || !data.stripeConnectAccountId) {
        setPaymentError('Failed to create payment intent');
        return;
      }
      setPaymentIntent({
        clientSecret: data.clientSecret,
        stripeConnectAccountId: data.stripeConnectAccountId,
      });
      setShowPaymentModal(true);
      setPaymentError(null);
    },
    onError: error => {
      setPaymentError(error.message || 'Failed to create payment');
    },
  });

  // New recurring payment creation
  const createRecurringPayment = useMutation({
    ...trpc.createRecurringPayment.mutationOptions(),
    onSuccess: data => {
      if (!data.clientSecret || !data.stripeConnectAccountId) {
        setPaymentError('Failed to create subscription');
        return;
      }
      setPaymentIntent({
        clientSecret: data.clientSecret,
        stripeConnectAccountId: data.stripeConnectAccountId,
      });
      setShowPaymentModal(true);
      setPaymentError(null);
    },
    onError: error => {
      setPaymentError(error.message || 'Failed to create subscription');
    },
  });

  const handlePayment = () => {
    if (!invoice) return;
    
    // For recurringOptional, check selected payment type
    if (invoice.type === 'recurringOptional') {
      if (selectedPaymentType === 'recurring') {
        createRecurringPayment.mutate({
          handle,
          invoiceId,
          customerEmail: invoice.client.email,
        });
      } else {
        createPaymentIntent.mutate({
          handle,
          invoiceId,
          paymentType: 'oneTime',
        });
      }
    }
    // For oneTime invoices, use payment intent
    else if (invoice.type === 'oneTime') {
      createPaymentIntent.mutate({ handle, invoiceId });
    }
    // For recurring invoices, use subscription
    else if (invoice.type === 'recurring') {
      createRecurringPayment.mutate({
        handle,
        invoiceId,
        customerEmail: invoice.client.email,
      });
    }
  };

  // ... existing loading/error states

  const isPaid = invoice.status === 'paid';
  const isVoided = invoice.status === 'voided';
  const isProcessing = createPaymentIntent.isPending || createRecurringPayment.isPending;

  return (
    <div className="min-h-screen bg-gray-50">
      {/* ... existing header */}
      
      <div className="mx-auto max-w-5xl px-4 py-8">
        <div className="grid gap-8 lg:grid-cols-3">
          {/* ... existing invoice preview */}
          
          {/* Payment Section */}
          <div className="lg:col-span-1">
            <Card className="sticky top-4">
              <div className="p-6">
                {/* ... existing amount display */}
                
                {/* Payment Type Toggle for recurringOptional */}
                {invoice.type === 'recurringOptional' && paymentOptions && (
                  <div className="mb-6">
                    <PaymentTypeToggle
                      options={paymentOptions}
                      selectedType={selectedPaymentType}
                      onTypeChange={setSelectedPaymentType}
                    />
                  </div>
                )}
                
                {/* Payment Actions */}
                {isPaid ? (
                  // ... existing paid state
                ) : isVoided ? (
                  // ... existing voided state  
                ) : (
                  <div className="space-y-4">
                    {paymentError && (
                      <div className="rounded-md border border-red-200 bg-red-50 p-3">
                        <Text variant="sm/medium" className="text-red-800">
                          {paymentError}
                        </Text>
                      </div>
                    )}
                    
                    <Button
                      className="w-full"
                      size="lg"
                      look="brand"
                      onClick={handlePayment}
                      disabled={isProcessing}
                    >
                      {isProcessing ? (
                        <>
                          <LoadingSpinner className="mr-2 h-4 w-4" />
                          {selectedPaymentType === 'recurring' ? 'Setting up subscription...' : 'Preparing payment...'}
                        </>
                      ) : (
                        <>
                          <Icon.creditCard className="mr-2 h-4 w-4" />
                          {selectedPaymentType === 'recurring' ? 'Subscribe' : 'Pay Now'}
                        </>
                      )}
                    </Button>
                    
                    {/* ... existing payment method info */}
                  </div>
                )}
              </div>
            </Card>
          </div>
        </div>
      </div>

      {/* ... existing modal */}
    </div>
  );
}
```

---

## Phase 5: Invoice Creation UI Updates

### Files to Modify:
- `apps/app/src/app/[handle]/invoices/_components/create-invoice-multi-step-form.tsx`
- `packages/ui/src/forms/` (add new form components if needed)

### Add Invoice Type Selection
In the invoice creation form, add:

```typescript
// Add to form schema
const createInvoiceFormSchema = z.object({
  // ... existing fields
  type: z.enum(['oneTime', 'recurring', 'recurringOptional']).default('oneTime'),
  billingInterval: z.enum(['monthly', 'quarterly', 'yearly']).nullable(),
  recurringDiscountPercent: z.number().min(0).max(100).default(0),
});

// Add to form UI
<SelectField
  control={form.control}
  name="type"
  label="Invoice Type"
  options={[
    { label: 'One-time Payment', value: 'oneTime' },
    { label: 'Recurring Payment', value: 'recurring' },
    { label: 'Customer Choice (Recommended)', value: 'recurringOptional' },
  ]}
/>

{(form.watch('type') === 'recurring' || form.watch('type') === 'recurringOptional') && (
  <>
    <SelectField
      control={form.control}
      name="billingInterval"
      label="Billing Frequency"
      options={[
        { label: 'Monthly', value: 'monthly' },
        { label: 'Quarterly', value: 'quarterly' },
        { label: 'Yearly', value: 'yearly' },
      ]}
    />
    
    <NumberField
      control={form.control}
      name="recurringDiscountPercent"
      label="Recurring Discount (%)"
      placeholder="0"
      min={0}
      max={100}
      step={0.1}
      description="Discount percentage for customers who choose recurring payments"
    />
  </>
)}

{form.watch('type') === 'recurringOptional' && form.watch('recurringDiscountPercent') > 0 && (
  <div className="rounded-lg bg-blue-50 p-4">
    <Text variant="sm/medium" className="text-blue-800">
      Preview: Customers will see savings of {formatMinorToMajorCurrency(
        calculateAnnualSavings(
          form.watch('total') || 0, 
          form.watch('recurringDiscountPercent') || 0,
          form.watch('billingInterval') || 'monthly'
        ), 
        form.watch('currency') || 'usd'
      )} per year when choosing recurring payments.
    </Text>
  </div>
)}
```

---

## Phase 6: Webhook Enhancements

### Files to Modify:
- `apps/app/src/app/api/stripe/connect/route.ts`

### Add Subscription Event Handlers
```typescript
// Add to existing webhook handler switch statement

case 'customer.subscription.updated': {
  const subscription = event.data.object;
  console.log('🔄 Subscription updated:', subscription.id);
  
  const { handleStripeSubscriptionUpdated } = await import(
    '@barely/lib/functions/stripe-connect.fns'
  );
  await handleStripeSubscriptionUpdated(subscription);
  break;
}

case 'customer.subscription.deleted': {
  const subscription = event.data.object;
  console.log('❌ Subscription deleted:', subscription.id);
  
  const { handleStripeSubscriptionDeleted } = await import(
    '@barely/lib/functions/stripe-connect.fns'
  );
  await handleStripeSubscriptionDeleted(subscription);
  break;
}

case 'invoice.payment_succeeded': {
  const invoice = event.data.object;
  console.log('💳 Invoice payment succeeded:', invoice.id);
  
  // Handle subscription invoice payments
  if (invoice.subscription) {
    const { handleStripeSubscriptionInvoiceSuccess } = await import(
      '@barely/lib/functions/stripe-connect.fns'
    );
    await handleStripeSubscriptionInvoiceSuccess(invoice);
  }
  break;
}

case 'invoice.payment_failed': {
  const invoice = event.data.object;
  console.log('❌ Invoice payment failed:', invoice.id);
  
  if (invoice.subscription) {
    const { handleStripeSubscriptionInvoiceFailed } = await import(
      '@barely/lib/functions/stripe-connect.fns'
    );
    await handleStripeSubscriptionInvoiceFailed(invoice);
  }
  break;
}
```

---

## Phase 7: Customer Management Features (Optional for MVP)

### Files to Create/Modify:
- `apps/app/src/app/[handle]/invoices/_components/invoice-subscription-management.tsx`
- Add subscription status to invoice list views

### Subscription Management Component
```typescript
// Basic subscription management for later implementation
export function InvoiceSubscriptionManagement({ invoice }: { invoice: Invoice }) {
  if (!invoice.subscriptionId || invoice.type === 'oneTime') {
    return null;
  }

  return (
    <Card className="p-4">
      <div className="flex items-center justify-between">
        <div>
          <Text variant="md/semibold">Subscription Status</Text>
          <Text variant="sm/normal" className="text-gray-600">
            {invoice.billingInterval} recurring payment
          </Text>
        </div>
        
        <Button
          size="sm"
          look="outline"
          onClick={() => {
            // TODO: Implement subscription cancellation
            console.log('Cancel subscription:', invoice.subscriptionId);
          }}
        >
          Manage Subscription
        </Button>
      </div>
    </Card>
  );
}
```

---

## Implementation Order & Testing Strategy

### Phase Implementation Order:
1. **Phase 1: Database** - Update schema and run migrations
2. **Phase 2: Backend** - Add subscription functions and update existing ones
3. **Phase 3: API** - Add new tRPC endpoints
4. **Phase 6: Webhooks** - Update webhook handlers (critical for subscription lifecycle)
5. **Phase 4: Frontend** - Update payment page with toggle
6. **Phase 5: Creation UI** - Add invoice type selection to admin
7. **Phase 7: Management** - Add subscription management features

### Testing Strategy:

#### Unit Tests:
- `calculateRecurringTotal()` function
- `calculateAnnualSavings()` function
- Payment type routing logic

#### Integration Tests:
- Subscription creation flow
- Webhook event processing
- Payment type toggle functionality

#### End-to-End Tests:
1. **OneTime Invoice**: Create → Send → Pay → Verify
2. **Recurring Invoice**: Create → Send → Subscribe → Verify first payment
3. **RecurringOptional Invoice**: 
   - Create → Send → Choose One-time → Pay → Verify
   - Create → Send → Choose Recurring → Subscribe → Verify
4. **Webhook Processing**: Simulate subscription events and verify database updates

#### Manual Testing Checklist:
- [ ] Create each invoice type successfully
- [ ] Payment page shows correct options for recurringOptional
- [ ] Toggle calculates savings correctly  
- [ ] One-time payment works via Payment Intent
- [ ] Recurring payment creates subscription
- [ ] Subscription webhooks update invoice status
- [ ] Subscription cancellation works
- [ ] Error handling for failed payments

---

## Success Criteria

### Technical Success:
- [ ] All invoice types (oneTime, recurring, recurringOptional) work end-to-end
- [ ] Payment routing works correctly based on invoice type and user selection
- [ ] Subscriptions are created with correct metadata and fees
- [ ] Webhooks properly handle subscription lifecycle events
- [ ] No breaking changes to existing one-time payment flow

### Business Success:
- [ ] Users can create recurring invoice templates
- [ ] Customers see clear value proposition for recurring payments (when discount > 0)
- [ ] Recurring payments reduce manual work for invoice creators
- [ ] Platform captures recurring revenue through subscription fees

### UX Success:
- [ ] Payment type toggle is intuitive and shows savings clearly
- [ ] No confusion between one-time and recurring options
- [ ] Clear feedback during subscription setup process
- [ ] Subscription management is accessible and clear

---

## Risk Mitigation

### Technical Risks:
1. **Webhook Reliability**: Implement retry logic and monitoring
2. **Subscription State Management**: Comprehensive error handling for failed subscription creation
3. **Fee Calculation**: Thorough testing of platform fee calculations across payment types

### Business Risks:
1. **User Adoption**: Start with existing power users, gather feedback
2. **Revenue Impact**: Monitor subscription vs one-time payment ratios
3. **Support Burden**: Clear documentation and error messages

### Deployment Strategy:
1. **Feature Flag**: Control rollout of recurring invoice creation
2. **Gradual Release**: Start with internal team, then beta users
3. **Monitoring**: Track payment success rates, error rates, subscription churn

---

## Future Enhancements (Post-MVP)

1. **Advanced Subscription Management**:
   - Pause/resume subscriptions  
   - Plan changes and prorations
   - Subscription analytics dashboard

2. **Enhanced Customer Experience**:
   - Customer portal for subscription self-service
   - Payment method updates
   - Billing history access

3. **Business Intelligence**:
   - Recurring revenue analytics
   - Churn prediction and prevention
   - Subscription cohort analysis

4. **Advanced Billing Features**:
   - Usage-based billing
   - Tiered pricing models
   - Custom billing schedules

---

This implementation guide provides a complete roadmap for adding Stripe Subscriptions support to the barely.ai invoice system while maintaining backward compatibility and providing a superior customer experience through the recurringOptional toggle feature.